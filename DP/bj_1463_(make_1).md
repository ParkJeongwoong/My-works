# 백준 1463번

1로 만들기

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력



## 입출력

| 입력 | 출력 |
| ---- | ---- |
| 2    | 1    |
| 10   | 3    |



## 주의사항

경우의 수 1, 2, 3을 순서대로 조건을 다는 것 보다 순서를 바꾸는 게 더 좋은 경우가 존재

Ex) 10의 경우, 10 -> 5 -> 4 -> 2 -> 1, [4]  보다,

​						 10 -> 9 -> 3 -> 1, [3] 이 더 짧다.



## 코드

```python
num = int(input())

# 10까지의 빈 list 생성
result = [0 for _ in range(num + 1)]

for i in range(1, num + 1):
    if i == 1:
        result[i] = 0
        continue
    # 숫자 i는 기본적으로 i-1에서 1을 더하면 얻을 수 있다. (step 1 추가)
    result[i] = result[i-1] + 1
    # 
    if i % 3 == 0 and result[i//3] + 1 < result[i]:
        result[i] = result[i//3] + 1
    if i % 2 == 0 and result[i//2] + 1< result[i]:
        result[i] = result[i//2] + 1

print(result[num])
        
```



## 설명

```
 num = 10일 때, list 배열
 0  1  2  3  4  5  6  7  8  9  10				#i
---------------------------------------------------
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]				#1
[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]				#2
[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]				#3
[0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 0]				#4
[0, 0, 1, 1, 2, 3, 0, 0, 0, 0, 0]				#5
[0, 0, 1, 1, 2, 3, 2, 0, 0, 0, 0]				#6
[0, 0, 1, 1, 2, 3, 2, 3, 0, 0, 0]				#7
[0, 0, 1, 1, 2, 3, 2, 3, 3, 0, 0]				#8
[0, 0, 1, 1, 2, 3, 2, 3, 3, 2, 0]				#9
[0, 0, 1, 1, 2, 3, 2, 3, 3, 2, 3] <= 최종 값	  #10
```

이 문제는 DP 방법을 이용해서 거꾸로, Bottom부터 접근해야 함.

즉 1 -> 2 -> 3 -> ... -> N 까지 올라가며 최적의 경우의 수를 찾아야 함



- 1이 아닌 정수 X에 적용 가능한 연산은 3가지

1. X - 1  => 이 경우, X는 연산 횟수는 (X-1) 연산보다 1 많음 => **dp[x] = dp[x-1] + 1**
2. X / 2  => 이 경우, X는 연산 횟수는 (X/2) 연산보다 1 많음 => **dp[x] = dp[x//2] + 1**
3. X / 3  => 이 경우, X는 연산 횟수는 (X/3) 연산보다 1 많음 => **dp[x] = dp[x//3] + 1**

- 리스트를 만들어 매 step<u>(dp[x])</u>을 기록하면서 다음 step에서 활용
  - **list에 step을 모두 기록하고, 이를 밟아간다는 느낌으로 코딩**



## 다른 방법

### min 활용

```python
info = {1: 0, 2: 1}

def find(n):
    # N이 1 or 2인 경우
    if n in info:
        return info[n]
    # 그 외의 경우
    m = 1 + min(find(n // 2) + n % 2, find(n // 3) + n % 3)
    info[n] = m
    return m

N = int(input())
print(find(N))
```



#### 설명

- 초기 조건, N이 1일 때, 2일 때의 결과값인 0 과 1을 info에 넣고 return
- 그 외의 경우
  - **[n/2]**에서 2를 곱한 값에 +1 을 몇 번 해야하는지(= **n%2**)
    - 일단 [n/2]에서의 값보다는 최소 1번 이상의 step이 필요 => **+1**
  - **[n/3]**에서 3을 곱한 값에 +1 을 몇 번 해야하는지(=**n%3**)
    - 역시 [n/3]에서의 값보다는 최소 1번 이상의 step이 필요 => **+1**
  - 더 작은 경우의 수를 m으로 저장
  - 해당 값을 dict info에 추가하고 return

=> list를 미리 만들어 놓지 않고 하나씩 추가하는 방식이라 조금 더 효율적

(첫 번째 경우는 N이 10일 때, for문 초기 i가 10보다 작은 경우에도 list에는 index 0부터 10까지의 data가 들어가 있다.)
