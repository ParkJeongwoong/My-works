T = int(input())

for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    step = 0

    for i in range(h):
        arr.append(input())
        step += arr[i].count('#')

    top = h  # 불이 켜진 꼭대기 층 찾기
    for i in range(h):
        if arr[-1-i].find('#') == -1:
            top -= 1
        else:
            break
    if not top:
        top = 1
    step += 2 * (top - 1) # 계단 오르내리는 건 여기서 다 더함

    ########################################################### 여기서 부턴 좌우 이동만 생각
    # print(step)

    # 왼쪽#######################################################
    def left(i,j,reserve,floor): # i층 왼쪽에 있을 때 # type j # 한 번 type search 해서 확인 j = 2로 확인
        # print('l floor',i, reserve, 'type',j,lying)
        sharp = arr[i].rfind('#')
        # 안 넘어가는 경우###############################
        if not j:
            if i == top-1:
                if not sharp+1: # 꼭대기인데 비었다? 특이한 케이스를 위한 경우(top에서 못잡아내는 전부 빈 건물)
                    return 0
                return 2 * sharp
            if not sharp + 1:
                return left(i+1,j,reserve[:],floor)
            return 2*sharp + left(i+1,0,reserve[:],[i,0])
        #################################################
        # 넘어가는 경우
        ##################################################
        # 다시 넘어 가는지 체크
        for ii in range(top-1):
            for iii in range(i+1,top):
                if arr[ii].rfind('#') + arr[iii].rfind('#') > w-1:
                    j = 2
                    break
        ########################
        ########################
        tmpstep = 0
        ######################## 기본 준비
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp < 0:
            rsharp = w-1
        ########################
        ######################## 여기서부터 본격적으로 검사
        if not sharp + 1: # 빈 층은 일단 넘김
            return left(i+1,j,reserve[:],floor) # 빈 층
        ####################################################
        ##############################################################################################################
        if j == 1: # reserve -1 좌측만 고려
            tmpstep = i-min(floor)
            itwasleft = 2*(sharp + i-1-floor[0]) # i-1층까지 올라온 뒤 하나 올라감
            itwasright = 2*(w-1-arr[i].find('#') + i-1-floor[1]) # 아래층에서 왼쪽으로 가서 left 함수를 탔지만 사실 오른쪽에서 현재 층을 확인했었음
            lfloor = [i,floor[1]]
            rfloor = [floor[0],i]
            if i == top-1:
                return min(itwasleft, 2*(lsharp+w-1-rsharp+tmpstep), itwasright) # 꼭대기 층
            return min(itwasleft+left(i+1,j,reserve,lfloor), 2*(lsharp+w-1-rsharp+tmpstep)+left(i+1,j,reserve,[i,i]), itwasright+left(i+1,j,reserve,rfloor)) # 일반 층
        ##############################################################################################################


        ##############################################################################################################
        elif j == 2: # reserve의 -1 너머도 고려


            tmpstep = i-min(floor)
            itwasleft = 2*(sharp + i-1-floor[0])
            itwasright = 2*(w-1-arr[i].find('#') + i-1-floor[1])
            lfloor = [i,floor[1]]
            rfloor = [floor[0],i]

            # print(tmpstep)

            # j = 2인 상태로 꼭대기 층에 오면 안 됨(벌칙 부과) // j = 2는 나중에 오른쪽으로 간다는 약속을 하고 이득을 보며 올라왔기 때문
            if i == top-1:
                if reserve[-1] + 1: # reserve를 사용한 경우 패널티 부과
                    return w-1 + right(i,reserve[:])
                return min(itwasleft, 2*(lsharp+w-1-rsharp+tmpstep), itwasright) # reserve를 안 썼으면 사실상 j==1과 같음
            # reserve는 나중에 오른쪽에 갔을 때 값을 치루겠다고 예약하는 것


            ##############################################################
            # sharp * 2 랑 이 경우는 reserve를 뺌
            # lsharp + w-1-rsharp 이 경우, reserve[-1]일 땐, reserve를 더함(나중에 위에서 내려가겠다는 뜻)
            # 한 번 오른쪽으로 갔다온 경우, 마찬가지로 lsharp + w-1-rsharp을 비교하는데, 이때 reserve는 오른쪽에서 최대로 올라간 곳을 의미
            # 가보지 않고서 정확히 어디서 넘어갈 지 알 수가 없음. 넘어간다는 확신만 있으면, reserve에 몽땅 때려넣고 가는 게 좋음(-1 기준으로 뒤가 미래 예약, 앞이 과거 기록)
            # [a,-1,d,e,f] d e f는 나중에 right으로 넘어가면 정산할 값들(오른쪽으로 가서 내려오면서 비용을 치룸) a는 과거에 이미 오른쪽에서 치룬 값들

            if not reserve[0]+1: # 한 번도 오른쪽으로 안 갔으면
                goright = w-1+right(i+1,reserve[:])
                present = 2*sharp + left(i+1,j,reserve[:],[i,floor[1]]) # 예약을 안 하겠다.
                future = 2*(lsharp + w-1-rsharp) + left(i+1,j,reserve+[i],[i,floor[1]]) # 다음을 약속하고 지금 이득을 취하겠다.
                # print('l',i,min(present, future, goright))
                return min(present, future, goright)
            else: # 오른쪽으로 갔다 온 거라면
                goright = w-1 + right(i+1,reserve[:])
                present = itwasleft + left(i+1,j,reserve,lfloor)
                past_both = 2*(lsharp + w-1-rsharp + tmpstep) + left(i+1,j,[i]+reserve,[i,i]) # 지난 번에 오른쪽에 있을 때 이미 지불함 / reserve 맨 앞으로 i로 바꿈
                past_right = itwasright+left(i+1,j,reserve,rfloor)
                future = 2*(lsharp + w-1-rsharp ) + left(i+1,j,reserve+[i],[i,floor[1]])
                return min(present, future, past_both, goright, past_right)
                

    def right(i,reserve):
        # print('r floor',i,reserve)
        # 그동안 reserve된 거 정산 = tmpstep
        tmpstep = 0
        if reserve[reserve.index(-1)+1:]:
            tmpstep += 2 * (i-1 - reserve[reserve.index(-1)+1]) # 가장 낮은 곳까지 내려갔다 옴 / 이 때 i-1층에서 올라와서 right i층이 되었으니 i-1부터 뺌
        sharp = arr[i].find('#')
        #######################################################################################
        # 꼭대기 층
        if i == top-1:
            return tmpstep + w-1 # 왼쪽으로 돌아가면서 정산된 값 더하기
        # 빈 층
        if not sharp + 1:
            return tmpstep + right(i+1,[-1])
        #######################################################################################
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp <0:
            rsharp = w-1
        #######################################################################################
        # 그냥 왼쪽으로 가는 경우
        # 오른쪽으로 유지하는 경우는, 그냥 오른쪽에서 다 처리하는 방법
        # 이따 왼쪽으로 넘어가서 마지막에 (0,0)으로 돌아가면서 처리하는 방법
        shorter = min(arr[i].rfind('#'), lsharp+w-1-rsharp, w-1-sharp)
        return tmpstep + min(2*shorter + right(i+1,[-1]), w-1 + left(i+1,1,[i,-1],[i,i]))


    # # 오른편으로 가는 게 이득일 경우 무조건 한 번은 넘어간다. (j=2)
    j = 0
    for ii in range(top-1):
        for iii in range(i+1,top):
            if arr[ii].rfind('#') + arr[iii].rfind('#') > w-1:
                j = 2
                break
    # 0은 오른편으로 아예 안 넘어감
    # 1은 오른편으로 갔다 온 이후
    # 2는 언젠가 오른편으로 넘어갈 예정
    step += left(0,j,[-1],[0,0]) # reserve[-1]은 아직 오른쪽으로 간 적이 없다는 표식

    print("#{} {}".format(tc, step))
