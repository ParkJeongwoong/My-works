# SWEA 11390 불 끄기 문제 - `D7`

불 끄기 문제를 푸는 과정을 기록

시작 시간 : 2021-02-09-10:00 AM 현재 상태 : 2021-02-11-08:00 PM / Fail (케이스 46/50개 성공)



## 1

```python
T = int(input())
 
for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    arrmap = []
    step = 0
 
    for i in range(h):
        arr.append(input())
        step += arr[i].count('#')
 
        left = arr[i].find('#')
        right = arr[i].rfind('#')
        if left == -1:
            arrmap.append(0)
        elif (left < half and right > w - half - 1) or (w % 2 and left == half):
            arrmap.append(2)
        elif left < half:
            arrmap.append(-1)
        else:
            arrmap.append(1)
 
    switch = {1: -1, -1: 1}
    loc = -1  # default, left
    store = 0  # arrmap이 0이면 그 층은 갈 필요 없음
    for i in range(len(arrmap)):
        if i == h-1: # 마지막층은 무조건 맞음
            if arrmap[i] ==0:
                continue
            elif loc > 0:
                step += w-1 + store
            else:
                step += 2 * arr[i].rfind('#') + store
        elif arrmap[i] == 2 or arrmap[i] * loc < 0:
            loc = switch[loc]
            step += w - 1 + store
            store = 0
        elif arrmap[i] * loc > 0:
            if loc < 0:
                step += 2 * arr[i].rfind('#') + store
            store = 0
        store += 2
 
    print("#{} {}".format(tc, step))
```

- for문으로 층을 올라가면서 확인



## 2

```python
T = int(input())
 
for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    step = 0
 
    for i in range(h):
        arr.append(input())
        step += arr[i].count('#')
 
    top = h  # 불이 켜진 꼭대기 층 찾기
    for i in range(h):
        if arr[-1-i].find('#') == -1:
            top -= 1
        else:
            break
    if not top:
        top = 1
    step += 2 * (top - 1) # 계단 오르내리는 건 여기서 다 더함
 
    ########################################################### 여기서 부턴 좌우 이동만 생각
 
    def left(i): # i층 왼쪽에 있을 때
        sharp = arr[i].rfind('#')
        if i == top-1:
            if not sharp+1:
                return 0
            return 2 * sharp
        if not sharp + 1:
            return left(i+1)
        return min(2*sharp + left(i+1), w-1 + right(i+1))
 
    def right(i):
        sharp = arr[i].find('#')
        if i == top-1:
            if not sharp+1:
                return w-1
            return w-1
        if not sharp + 1:
            return right(i+1)
        return min(2*arr[i].rfind('#',0,-1) + right(i+1), 2*(w-1-sharp) + right(i+1), w-1 + left(i+1))
 
    step += left(0)
 
    print("#{} {}".format(tc, step))
```

- 함수로 풀기 시작
- 꼭대기 층이 불이 꺼져있는 층 이후부터는 탐색할 필요가 없으므로 top변수를 확인
- 위아래 이동, 불 끄는 횟수는 전부 미리 계산 / 함수는 좌우 이동만 계산



## 3

```python
T = int(input())
 
for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    step = 0

    for i in range(h):
        step += arr[i].count('#')

    top = h  # 불이 켜진 꼭대기 층 찾기
    for i in range(h):
        if arr[-1-i].find('#') == -1:
            top -= 1
        else:
            break
    if not top:
        top = 1
    step += 2 * (top - 1) # 계단 오르내리는 건 여기서 다 더함

    ########################################################### 여기서 부턴 좌우 이동만 생각
    # 지금까지와는 반대로, 건너편 계단으로 갈 필요가 없는 경우를 생각해보자
    # 왼쪽에 있고 오른편에 불이 없을 때, 오른쪽에 있고 왼편에 불이 없을 때(마지막층이 아닐 때)
    # N <= 8, 이 뜻은 2의 제곱 방식으로 계산해도 된다는 뜻 => 완전탐색이 답
    def left(i,j): # i층 왼쪽에 있을 때
        sharp = arr[i].rfind('#')
        if j:
            lsharp = arr[i].rfind('#',0,half)
            rsharp = arr[i].find('#',half)
            if lsharp < 0:
                lsharp =0
            if rsharp <0:
                rsharp = w-1
            shorter = min(sharp, lsharp+w-1-rsharp, w-1-arr[i].find('#'))
            
        if i == top-1:
            if not sharp+1:
                return 0
            if j:
                return 2 * shorter
            return 2 * sharp
        if not sharp + 1:
            return left(i+1,j)
        if j:
            return 2 * shorter+ left(i+1,1) # right 안 해도 되나?
        return min(2*sharp+left(i+1,0), w-1+right(i+1))

    def right(i):
        sharp = arr[i].find('#')
        if i == top-1:
            if not sharp+1:
                return w-1
            return w-1
        if not sharp + 1:
            return right(i+1)
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp <0:
            rsharp = w-1
        shorter = min(arr[i].rfind('#'), lsharp+w-1-rsharp, w-1-sharp)
        return min(2*shorter+right(i+1), w-1 + left(i+1,1))

    step += left(0,0)

    print("#{} {}".format(tc, step))
```

- left에 j 변수를 추가해서 오른쪽으로 가기 전에는 0, 오른쪽으로 갔다가 돌아오는 경우 1을 반환



## 4

```python
T = int(input())
 
for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    step = 0
 
    for i in range(h):
        arr.append(input())
        step += arr[i].count('#')
 
    top = h  # 불이 켜진 꼭대기 층 찾기
    for i in range(h):
        if arr[-1-i].find('#') == -1:
            top -= 1
        else:
            break
    if not top:
        top = 1
    step += 2 * (top - 1) # 계단 오르내리는 건 여기서 다 더함
 
    ########################################################### 여기서 부턴 좌우 이동만 생각
     
    def left(i,j,reserve): # i층 왼쪽에 있을 때 # type j
        sharp = arr[i].rfind('#')
        tmpstep = 0
        if j:
            lsharp = arr[i].rfind('#',0,half)
            rsharp = arr[i].find('#',half)
            if lsharp < 0:
                lsharp =0
            if rsharp < 0:
                rsharp = w-1
            if j == 1:
                if sharp > lsharp+w-1-rsharp:
                    tmpstep += 2*(i-reserve[0])
                    reserve[0] = i
                shorter = min(sharp, lsharp+w-1-rsharp, w-1-arr[i].find('#'))
            elif j == 2:
                if sharp > lsharp+w-1-rsharp+2:
                    reserve.append(i)
                    shorter = lsharp+w-1-rsharp+2
                else:
                    shorter = sharp
             
        if i == top-1:
            if not sharp+1:
                return 0
            if j:
                return 2 * shorter + tmpstep
            return 2 * sharp
        if not sharp + 1:
            return left(i+1,j,reserve[:]) + tmpstep
        # 특이 케이스가 아닌 경우
        if j:
            return min(2*shorter+left(i+1,j,reserve[:]), w-1+right(i+1,reserve[:])) + tmpstep
        return 2*sharp+left(i+1,0,reserve[:]) + tmpstep
 
    def right(i,reserve): # 오른쪽으로 내려갔다가 다시 올라오는 경우
        tmpstep = 0
        if reserve:
            tmpstep += 2 * (i-reserve[0])
        sharp = arr[i].find('#')
        if i == top-1:
            return w-1 +tmpstep
        if not sharp + 1:
            return right(i+1,[i+1]) + tmpstep
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp <0:
            rsharp = w-1
        shorter = min(arr[i].rfind('#'), lsharp+w-1-rsharp, w-1-sharp) # 수정 가능할듯
        return min(2*shorter+right(i+1,[i+1]), w-1 + left(i+1,1,[i])) + tmpstep
 
    # aftercheck = 0 # 중간에 넘어가는지, 넘어간다면 어디서 넘어가는지 확인 => 넘어가면 오른쪽에서 내려갔다가 올라오는 경우를 적용
    # # 오른편으로 가는 게 이득일 경우 무조건 한 번은 넘어간다.
    gocheck = 0
    j = 0
    reserve=[]
    for i in range(top):
        if arr[i].rfind('#',half) > 0:
            gocheck += 1
            if gocheck == 2:
                j = 2
                break
    # 0은 오른편으로 아예 안 넘어감
    # 1은 오른편으로 갔다 온 이후
    # 2는 언젠가 오른편으로 넘어갈 예정
    step += left(0,j,reserve)
 
    print("#{} {}".format(tc, step))
```

- j 타입에 0, 1, 2 세 가지로 나누고 0은 넘어가지 않는 경우, 1은 넘어갔다가 오는 경우, 2는 넘어갈 예정인 경우로 나눔

- reserve 변수를 추가해서 바로 넘어가지 않고 나중에 오른쪽으로 넘어가서 확인하는 logic을 추가

  ```
  ####
  ####
  ...#
  ```



## 최종 (92% 완성)

```python
T = int(input())

for tc in range(1, T + 1):
    h, w = map(int, input().split())
    half = w // 2  # half보다 작으면 굳이 끝까지 갈 필요 X
    arr = []
    step = 0

    for i in range(h):
        arr.append(input())
        step += arr[i].count('#')

    top = h  # 불이 켜진 꼭대기 층 찾기
    for i in range(h):
        if arr[-1-i].find('#') == -1:
            top -= 1
        else:
            break
    if not top:
        top = 1
    step += 2 * (top - 1) # 계단 오르내리는 건 여기서 다 더함

    ########################################################### 여기서 부턴 좌우 이동만 생각
    # print(step)

    # 왼쪽#######################################################
    def left(i,j,reserve): # i층 왼쪽에 있을 때 # type j # 한 번 type search 해서 확인 j = 2로 확인
        # print('l floor',i, reserve, 'type',j)
        sharp = arr[i].rfind('#')
        # 안 넘어가는 경우###############################
        if not j:
            if i == top-1:
                if not sharp+1: # 꼭대기인데 비었다? 특이한 케이스를 위한 경우(top에서 못잡아내는 전부 빈 건물)
                    return 0
                return 2 * sharp
            if not sharp + 1:
                return left(i+1,j,reserve[:])
            return 2*sharp + left(i+1,0,reserve[:])
        #################################################
        # 넘어가는 경우
        ##################################################
        # 다시 넘어 가는지 체크
        for ii in range(top-1):
            for iii in range(i+1,top):
                if arr[ii].rfind('#') + arr[iii].rfind('#') > w-1:
                    j = 2
                    break
        ########################
        # 넘어가면 j = 2(reserve 받은 것과 gofloor 참조) / 안 넘어가면 j = 1(reserve 받은 것만 참조)
        ########################
        tmpstep = 0
        ######################## 기본 준비
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp < 0:
            rsharp = w-1
        ########################
        ######################## 여기서부터 본격적으로 검사
        if not sharp + 1: # 빈 층은 일단 넘김
            return left(i+1,j,reserve[:]) # 빈 층
        ####################################################
        ##############################################################################################################
        if j == 1: # reserve 받은 것만 참조
            tmpstep = i-reserve[0]
            if i == top-1:
                return min(2*sharp, 2*(lsharp+w-1-rsharp+tmpstep), 2*(w-1-arr[i].find('#'))) # 꼭대기 층
            return min(2*sharp+left(i+1,j,reserve[:]), 2*(lsharp+w-1-rsharp+tmpstep)+left(i+1,j,[i,-1])) # 일반 층
        ##############################################################################################################


        ##############################################################################################################
        elif j == 2: # reserve 받은 것과 gofloor 참조 ## 이후 문제가 있다면 go floor 탐색에 문제가 있을 가능성이 있음

            # j = 2인 상태로 꼭대기 층에 오면 안 됨(벌칙 부과) // j = 2는 나중에 오른쪽으로 간다는 약속을 하고 이득을 보며 올라왔기 때문
            if i == top-1:
                return w-1 + right(i,reserve[:])
            # reserve는 나중에 오른쪽에 갔을 때 값을 치루겠다고 예약하는 것


            ##############################################################
            # sharp * 2 랑 이 경우는 reserve를 뺌
            # lsharp + w-1-rsharp 이 경우, reserve[-1]일 땐, reserve를 더함(나중에 위에서 내려가겠다는 뜻)
            # 한 번 오른쪽으로 갔다온 경우, 마찬가지로 lsharp + w-1-rsharp을 비교하는데, 이때 reserve는 오른쪽에서 최대로 올라간 곳을 의미
            # 가보지 않고서 정확히 어디서 넘어갈 지 알 수가 없음. 넘어간다는 확신만 있으면, reserve에 몽땅 때려넣고 가는 게 좋음(-1 기준으로 뒤가 미래 예약, 앞이 과거 기록)
            # [a,-1,d,e,f] d e f는 나중에 right으로 넘어가면 정산할 값들(오른쪽으로 가서 내려오면서 비용을 치룸) a는 과거에 이미 오른쪽에서 치룬 값들

            if not reserve[0]+1: # 한 번도 오른쪽으로 안 갔으면
                goright = w-1+right(i+1,reserve[:])
                present = 2*sharp + left(i+1,j,reserve[:]) # 예약을 안 하겠다.
                future = 2*(lsharp + w-1-rsharp) + left(i+1,j,reserve+[i]) # 다음을 약속하고 지금 이득을 취하겠다.
                # print('l',i,min(present, future, goright))
                return min(present, future, goright)
            else: # 오른쪽으로 갔다 온 거라면
                goright = w-1 + right(i+1,reserve[:])
                present = 2*sharp + left(i+1,j,reserve[:])
                past = 2*(lsharp + w-1-rsharp + i-reserve[0]) + left(i+1,j, [i]+reserve) # 지난 번에 오른쪽에 있을 때 이미 지불함 / reserve 맨 앞으로 i로 바꿈
                future = 2*(lsharp + w-1-rsharp ) + left(i+1,j,reserve+[i])
                return min(present, future, past, goright)
                

    def right(i,reserve):
        # print('r floor',i,reserve)
        # 그동안 reserve된 거 정산 = tmpstep
        tmpstep = 0
        if reserve[reserve.index(-1)+1:]:
            tmpstep += 2 * (i-1 - reserve[reserve.index(-1)+1]) # 가장 낮은 곳까지 내려갔다 옴 / 이 때 i-1층에서 올라와서 right i층이 되었으니 i-1부터 뺌
        sharp = arr[i].find('#')
        #######################################################################################
        # 꼭대기 층
        if i == top-1:
            return tmpstep + w-1 # 왼쪽으로 돌아가면서 정산된 값 더하기
        # 빈 층
        if not sharp + 1:
            return tmpstep + right(i+1,[-1])
        #######################################################################################
        lsharp = arr[i].rfind('#',0,half)
        rsharp = arr[i].find('#',half)
        if lsharp < 0:
            lsharp =0
        if rsharp <0:
            rsharp = w-1
        #######################################################################################
        # 그냥 왼쪽으로 가는 경우
        # 오른쪽으로 유지하는 경우는, 그냥 오른쪽에서 다 처리하는 방법
        # 이따 왼쪽으로 넘어가서 마지막에 (0,0)으로 돌아가면서 처리하는 방법
        shorter = min(arr[i].rfind('#'), lsharp+w-1-rsharp, w-1-sharp)
        # print('!',arr[i].find('#'))
        # print('r',i,shorter,min(2*shorter + right(i+1,[-1]), w-1 + left(i+1,1,[i,-1])))
        return tmpstep + min(2*shorter + right(i+1,[-1]), w-1 + left(i+1,1,[i,-1]))


    # # 오른편으로 가는 게 이득일 경우 무조건 한 번은 넘어간다. (j=2)
    j = 0
    reserve=[-1] # reserve[-1]은 아직 오른쪽으로 간 적이 없다는 표식
    for ii in range(top-1):
        for iii in range(i+1,top):
            if arr[ii].rfind('#') + arr[iii].rfind('#') > w-1:
                j = 2
                break
    # 0은 오른편으로 아예 안 넘어감
    # 1은 오른편으로 갔다 온 이후
    # 2는 언젠가 오른편으로 넘어갈 예정
    step += left(0,j,reserve)

    print("#{} {}".format(tc, step))
```

- 생각하는 거의 모든 경우의 수를 해결하기 위해 로직 추가



```
내가 생각한 최종 패턴
.#......#.
.########.
.#......#.
........#.
.#......#.
.########.
.#........
.#......#.
```

