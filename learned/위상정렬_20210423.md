# 위상정렬

> 양명균 교수님의 위상정렬 특강

## 위상정렬이란

**순서가 있는** 작업을 차례로 진행해야 할 때 <u>순서를 결정하기 위한</u> 알고리즘

**사이클이 없는 방향 그래프**의 모든 노드를 방향성에 어긋나지 않게 순서를 나열하는 것

> 예) 대학 선수과목 ,공장의 작업 순서, 요리 순서



### 사전지식

- DAG (Directed Acyclid Graph: 유향 비사이클 그래프)

- 진입 차수 - 특정 노드로 들어오는 간선의 개수
- 진출 차수 - 특정 노드에서 나가는 간선의 개수



## 위상정렬 방법

### Queue 사용

1) **진입 차수**가 0인 모든 노드를 큐에 삽입 // 진출 차수는 필요 X

2) 큐가 공백 상태가 될 때까지 반복

​	1) <u>큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거</u>

​		**`(연결 된 노드의 진입 차수를 감소)`**

​	2) 새롭게 진입 차수가 0이 된 노드를 큐에 삽입

\>\>  **큐에서 꺼내지는 순서**(= 큐에 들어간 순서)가 `위상 정렬을 수행한 결과`



[의사 코드]

```
G : 인접 리스트
In_degree : 진입차수 저장배열
Q: 큐

Topological_sort () {
	Q <- indegree가 0인 노드 삽입
	while (!Q_isEmpty) {
		node = deQueue // 결과 추가
		for v in G[node] {
			in_degree[v] -= 1
			if (in_degree[v] == 0) { enQueue(v) }
		}
	}
}
```



### Stack 사용

1) 진입 차수가 0인 모든 노드에서 DFS 시작

2) DFS 탐색

​	1) 해당 노드를 방문 표시

​	2) 인접하면서 방문하지 않은 노드가 있다면 DFS 재귀호출

​	3) 함수를 return 하기 전 Stack에 현재 노드 저장

3) Stack이 공백상태가 될 때까지 pop

\>\>  **스택에서 꺼내지는 순서를 뒤집으면** `위상 정렬을 수행한 결과`



[의사 코드]

```
G : 인접 리스트
In_degree : 진입차수 저장배열
Stack: 큐
Visited: 방문배열

Topological_sort (v) { //v: 노드
	visited[v] = True
	for u in G[v] {
		if (visited[u] == False) { Topological_sort(u) }
	}
	Stack.push(v)
}

for i in 노드번호 {
	if (in_degree[i] == 0) { Topological_sort(i) }
}
```



## 위상정렬 특징

- 모든 정점을 방문하기 전에 큐가 공백상태가 되면 사이클이 존재하는 것

  (사이클이 존재하면 진입 차수가 0이 될  수 없음)

- 그래프 유형은 DAG

- 여러가지 해답이 존재할 수 있다.

  (진입 차수가 0인 값이 동시에 생성된다면 작성한 코드에 따라 답이 달라진다)

- 시간 복잡도 O(V + E)