# OS

- **`프로세스 vs 스레드`**
  - **프로세스는** 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(**Code, Data, Heap, Stack**)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.
  - **쓰레드는** 프로세스 내에서 **Stack만 따로 할당** 받고, 그 이외의 메모리 영역(**Code, Data, Heap**)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
- **`프로그램 & 프로세스`**
  - 크롬 파일 -> 프로그램
  - 더블 클릭해서 실행시키면 -> 프로세스

- **`멀티프로세스 vs 멀티스레드`**
  - **멀티 프로세스는** 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만
    멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.
    - 브라우저 탭
  - **멀티 쓰레드는** 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만
    하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.
    - WAS Request
- **`멀티스레드의 동시성과 병렬성`**
  - 동시성 : 여러 개의 스레드가 번갈아가며 실행 -> 동시에 실행하는 것처럼 보이는 것
  - 병렬성 : 멀티 코어에서 각 코어가 실제로 동시해 실행

- **`데드락`**
  - 조건
    - 비선점 (Nonpreemptive) : 다른 프로세스의 **자원을 뺏을 수 없음.**
    - 순환 대기 (Circular wait) : 두 개 이상의 프로세스가 **순환적 구조로 자원 접근을 기다림.**
    - 점유 대기 (Hold & Wait) : 공유 자원에 대한 **접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.**
    - 상호 배제(Mutual Exclusion) : **한 번에 한 프로세스만 공유 자원에 접근** 가능하며, 접근 권한이 제한적일 경우.
  - 은행원 알고리즘
    - 안정상태와 불안정상태로 나눠 데드락이 발생하지 않는 안정상태 조건에서만 자원 점유
- **`콘보이 현상`**
  - 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다음 프로세스들의 실행시간이 늦춰지는 문제
- **`선점형 스케줄링과 비선점형 스케줄링`**
  - 선점형은 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 있음을 말하고,
  - 비선점형은 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음을 말합니다.

- **`동기와 비동기`**
  - 동기 : Block 처리
  - 비동기 : Non Block 처리

- **`Critical Section(임계영역)`**
  - 임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 <u>한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역</u>을 말합니다. 임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.
    1. 상호 배제(Mutual exclution) - 하나의 프로세스가 임계 영역에 들어가 있다면 **다른 프로세스는 들어갈 수 없어야 한다.**
    2. 진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 **어느 것이 먼저 들어갈지 결정** 해주어야 한다.
    3. 한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, **한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한**을 두어야 한다.

- **`뮤텍스(Mutex)와 세마포어(Semaphore)`**
  - **뮤텍스**는 Lock을 사용해 <u>하나의 프로세스나 쓰레드를 단독으로 실행</u>
    - 뮤텍스는 락(lock)을 획득한 프로세스만 해제 가능
  - **세마포어**는 공유자원에 <u>세마포어 변수만큼의 프로세스(또는 스레드)가 접근 가능</u>
    - 수행 중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제 가능

- **`페이지 교체 알고리즘`**
  - 메모리에 페이지가 부재시 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법
    - **FIFO(first in first out)**
    - **LRU(least-recently-used)**
      - 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘입니다.
    - **LFU(least-frequently-used)**
      - 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘입니다.
    - **MFU(most-frequently-used)**
      - LFU 알고리즘과 반대로, 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘입니다.
  - `LFU와 MFU는 실제 사용에 잘 쓰이지 않는다.`
    - 구현에 상당한 비용이 들고,
    - 최적 페이지 교체 정책을 (LRU 만큼) 제대로 유사하게 구현해내지 못하기 때문이다.

- **`컨텍스트`**
  - CPU가 프로세스를 실행하기 위해 필요한 해당 프로세스의 정보
  - ❓**컨텍스트 스위칭(Context Switching)**
    - 멀티프로세스 환경에서 CPU가 **어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업**을 말합니다.

- **`단편화`**
  - **내부단편화**
    - 페이징을 하 메모리를 일정한 크기로 나누고 프로세스를 할당할 때 한 <u>페이지 안에서 빈 공간이 생기는 것</u>
      - 100MB 씩 메모리를 나눴는데, 250MB 프로세스는 마지막 3번째 페이지가 50MB만 들어가고 50MB만큼의 낭비 발생 (내부단편화)
  - **외부단편화**
    - 세그먼테이션을 하여 프로세스를 논리 단위로 나누고 각자 다른 크기의 메모리를 배정했을 때, 할당과 해제가 반복되며 <u>세그먼트 사이에 빈 공간이 생기는 것</u>
      - 150MB 프로세스 A 뒤에 50MB 프로세스 B를 띄우고 프로세스 A를 해제 후 100MB 프로세스 C를 프로세스 A 자리에 할당하면 프로세스 C 세그먼트와 B 세그먼트 사이에 50MB만큼의 낭비 발생 (외부단편화)
  - ❓**메모리 풀**
    - 프로세스가 필요한 공간을 미리 할당 받고 할당 받은 범위 안에서 프로세스가 자체적으로 할당과 해제를 반복
    - 미리 공간을 필요한 만큼 조절해서 할당받기 때문에 외부단편화 X
    - 미리 필요한 크기를 할당 받아서 내부단편화 X
    - 다만 할당받고 쓰지 않은 경우 메모리 낭비가 굉장히 큼
    - <u>메모리 할당과 해제가 잦은 경우에 효과적</u>