# DB

- `DDL, DML, DCL`

  - DDL (정의어 : Data Definition Language) : 데이터베이스 구조를 정의, 수정, 삭제하는 언어 ( alter, create, drop )
  - DML (조작어 : Data Manipulation Language) : 데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 ( select, insert, update, delete )
  - DCL (제어어 : Data Control Language) : 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어 ( commit, rollback, grant, revoke )

- `SELECT 수행 순서`

  - ***FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT >* *DISTINCT* *>* *ORDER BY* *> LIMIT***

    **1. FROM**

    \- 각 테이블을 확인한다.

    **2. ON**

    \- JOIN 조건을 확인한다.

    **3. JOIN**

    \- JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.

    **2. WHERE**

    \- 데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용된다. WHERE절의 제약 조건은 FROM절로 가져온 테이블에 적용될 수 있다.

    **3. GROUP BY**

    \- WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.

    **4. HAVING**

    \- GROUP BY절이 쿼리에 있을 경우 HAVING 절의 제약조건이 그룹화된 행에 적용된다.

    **5. SELECT**

    \- SELECT에 표현된 식이 마지막으로 적용된다.

    **6. DISTINCT**

    \- 표현된 행에서 중복된 행은 삭제

    **7.ORDER BY**

    \- 지정된 데이터를 기준으로 오름차순, 내림차순 지정

    **8. LIMIT**

    \- LIMIT에서 벗어나는 행들은 제외되어 출력된다.

- `Index`
  - 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.
  - 즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능
  - ❓자료구조
    - B+Tree, 해시 테이블
- `정규화`
  - 테이블의 컬럼별로 유일한 의미를 지니게 만드는 것
  - 이상현상을 없앤다
  - A 테이블에 있는 컬럼이 B 테이블에도 있지 않도록 만드는 것
  - Join이 많아져 성능이 안 좋아질 수 있다
  - 이 때문에 Join이 많은 테이블의 경우 역정규화를 하기도 한다
  
- `이상현상`
  - **삽입 이상** : 자료를 삽입할 때 특정 속성에 <u>해당하는 값이 없어 NULL을 입력</u>해야 하는 현상
  - **갱신 이상** : 중복된 데이터 중 <u>일부만 수정</u>되어 데이터 모순이 일어나는 현상
  - **삭제 이상** : 어떤 정보를 삭제하면, <u>의도하지 않은 다른 정보까지 삭제</u>되어버리는 현상

- `RDBMS`
  - **RDBMS**는 모든 데이터를 2차원 테이블 형태로 표현합니다.
    - 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
    - 단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)
  - **NoSQL**(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.
    - **장점** : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
    - 데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.
    - **단점** : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
    - 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.
  - ❓사용처
    - **RDBMS**는 <u>데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우</u> 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
    - **NoSQL**은 <u>정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우</u> 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 **Scale-out** 해야 되는 시스템에 적합합니다.
- **`트랜잭션의 특성 ACID`**
  - **원자성**(Atomicity) 작업이 <u>모두 반영</u>되던지 아니면 전혀 반영되지 않아야 한다.
  - **일관성**(Consistency) <u>언제나 일관성 있는 데이터</u>를 유지해야 한다.
  - **격리성**(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 <u>서로의 연산에 끼어들 수 없다.</u>
  - **영속성**(Durability) 완료된 결과는 <u>영구적으로 반영</u>되어야 한다.
- **`DB Lock`**
  - **공유락**(LS, Shared Lock) Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다. (**PESSIMISTIC_READ**)
  - **베타락**(LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다. (**PESSIMISTIC_WRITE**)

- **`DELETE, TRUNCATE, DROP의 차이`**
  - **DELETE는** 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제 후 되돌릴 수 있습니다.
  - **TRUNCATE는** 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 <u>인덱스 등도 삭제</u>되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없습니다.
  - **DROP은** 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제 후 되돌릴 수 없습니다.
- **`데이터베이스 클러스터링과 리플리케이션의 차이`**
  - **클러스터링이란 여러 개의 DB를 수평적인 구조로 구축**하는 방식입니다. **동기 방식으로 사용**되며, 다음과 같은 장단점이 있습니다.
    - 장점 :
      - DB 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
        1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다. (높은 가용성)
        기존에 하나의 DB서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다. (로드밸런싱)
    - 단점 :
      - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
        서버를 동시에 운영하기 위한 비용이 많이 든다.
  - **리플리케이션은 여러 개의 DB를 권한에 따라 수직적인 구조로 구축**하는 방식입니다. **비동기 방식으로 사용**되며, 다음과 같은 장단점이 있습니다.
    - 장점 :
      - DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
        비동기 방식으로 운영되어 지연 시간이 거의 없다.
    - 단점 :
      - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
        Master DB가 다운되면 복구 및 대처가 까다롭다.

- **`Cardinality & Selectivity`**
  - Cardinality : 특정 데이터셋의 유니크한 갯수
    - 1, 2, 3, 3, 4 => Cardinality = 4
    - 가, 나, 다, 라, 마 => Cardinality = 5
  - Selectivity : Cardinality / 전체 데이터 수, 1일 경우 유니크한 데이터셋이라는 뜻
    - 1, 2, 3, 3, 4 => Selectivity  = 4/5 = 0.8
    - 가, 나, 다, 라, 마 => Selectivity  = 5/5 = 1
  - <u>선택도가 높은 컬럼을 인덱스로 고르는 게 좋다</u>

- **`결합 인덱스`**
  - 여러 개의 컬럼을 묶어 인덱스로 쓰는 것
  - 순서가 매우 중요
    - A - B - C 순이면 A에 대해 정렬 -> B에 대해 정렬 -> C에 대해 정렬을 한다는 뜻. **즉 순서대로 찾는다는 뜻**