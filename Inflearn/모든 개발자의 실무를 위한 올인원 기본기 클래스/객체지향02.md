# 객체 지향 특성

```
출처 : 모든 개발자의 실무를 위한 올인원 기본기 클래스
```



## 객체지향의 4대 특성

1. 상속

2. 추상화
3. 다형성
4. 캡슐화



### 책임과 협력

#### 책임

- 객체가 **수행해야 하는 범위와 기능**

`SRP (Single Responsiblity Principle)` : 하나의 객체는 하나의 책임을 가지는 것 => 명확한 정체성, 변경 용이, 재사용 가능, **높은 응집도**, **낮은 결합도**



#### 협력

- 객체 간의 **의존**

`책임 주도 설계` : <u>상황에 필요한 객체</u>의 **책임을 중심으로 시스템을 설계** => 명확한 정체성, **높은 응집도**, **낮은 결합도**



### 추상화 & 상속

[추상화]

구체적인 객체들을 포함하는 추상적인 개념

(자동차라는 추상적인 개념은 거리에 있는 수많은 실제 소나타와 BMW, 포르쉐를 포함한다)

=> "자동차를 탄다"라고 하는 것이 "소나타를 탄다"라고 하는 것보다 훨씬 범용성 높은 표현임

```python
class Human:
    def __init__(self) -> None:
        self.car = None
        
    def getCar(self, car_name: str) -> None:
        if car_name = "sonota":
            self.car = SonataCar()
        elif car_name = "porsche":
            self.car = PorscheCar()
    
    def driveCar(self -> None):
        self.car.drive()

class SonotaCar:
    pass
class PorscheCar:
    pass
```

이 코드보다 아래의 추상화된 코드가 낫다

```python
class Human:
    def __init__(self) -> None:
        self.car = None
        
    def getCar(self, car: Car) -> None:
        self.car = car
    
    def driveCar(self) -> None:
        self.car.drive()

class Car(ABC):
    pass
class SonotaCar(Car):
    pass
class PorscheCar(Car):
    pass
```

> getCar 부분에 포르쉐, 소나타 객체를 넘겨주는 일은 기능적으로 위의 코드에서도 가능하다.
>
> 하지만 함수에 아무 타입이나 넘겨주는 일은 추후에 문제를 발생시킬 수 있기 때문에 항상 같은 타입을 전달해야 한다.
>
> 포르쉐와 소나타는 서로 다른 클래스이기 때문에 위의 코드에서는 getCar 메서드에 문자열을 넘겨주고 객체를 생성하는 건 getCar 메서드 내에서 진행했다.
>
> 이런 경우, 만약 주인이 없는 자동차라는 개념이 생길 경우 난감해질 수 있다. 
>
> 그 차가 주인에게 인도되는 과정에 관련된 함수가 또 필요하기 때문이다. (즉 처음부터 주인이 있는 소나타 객체는 getCar로 생성되고 처음에 주인이 없었다가 새로 주인이 생길 경우, 혹은 차의 주인이 바뀌는 경우 관련된 새로운 함수를 사용해야 한다)
>
> 하지만 아래 코드처럼 소나타와 포르쉐를 모두 포함하는 "자동차"라는 개념을 만든다면, getCar 함수에 Car라는 개념이 들어간다고 선언할 수 있고 이 경우 소나타 객체가 들어가든, 포르쉐 객체가 들어가든 상관없어진다. 이는 자동차 객체의 생성을 Human 객체에서 분리시킴으로써 자동차 객체가 Human과 완전히 독립적으로 존재할 수 있게 한다.







### 다형성









### 캡슐화
